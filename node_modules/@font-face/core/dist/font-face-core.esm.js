var arrify = function (value) {
  if (value === null || value === undefined) {
    return [];
  }

  if (Array.isArray(value)) {
    return value;
  }

  if (typeof value === 'string') {
    return [value];
  }

  if (typeof value[Symbol.iterator] === 'function') {
    return [].concat( value );
  }

  return [value];
};

var arrify_1 = arrify;

var arrayJoin = function (array, separator) {
  return array.filter(function (item) { return item != undefined; }).join(separator);
};
var arrayJoinMap = function (array, fn, separator, useArrayJoin) {
  var mappedArray = array.map(fn);
  return useArrayJoin ? arrayJoin(mappedArray, separator) : mappedArray.join(separator);
};

/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}

var isFunction_1 = isFunction;
var toString = Object.prototype.toString;

function isFunction(fn) {
  var string = toString.call(fn);
  return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && ( // IE8 and below
  fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
}

var jsonTemplate = {
  configify: function configify(tplConfig) {
    if (isObject(tplConfig)) {
      return tplConfig;
    } else {
      return {
        tpl: tplConfig
      };
    }
  },

  resolveTpl: function resolveTpl() {
    return isFunction_1(tpl) ? tpl() : tpl;
  },

  isNotValidTplConfig: function isNotValidTplConfig(tplConfig) {
    return tplConfig == null;
  },

  isTplParseable: function isTplParseable(tpl) {
    return Array.isArray(tpl) || isObject(tpl);
  },

  isConditionTruty: function isConditionTruty(tplConfig) {
    if (isObject(tplConfig)) {
      var conditionDefined = Object.prototype.hasOwnProperty.call(tplConfig, 'condition');
      return conditionDefined ? tplConfig.condition : true;
    } else {
      throw 'Config is not valid. Please report this as a bug.';
    }
  },

  parse: function parse(tpl, joinChar) {
    var this$1 = this;
    if ( joinChar === void 0 ) joinChar = '';

    return arrayJoinMap(arrify_1(tpl), function (tplConfig) {
      // return if config is null or undefined
      if (this$1.isNotValidTplConfig(tplConfig)) { return null; } // convert to obj if config is string

      var tplConfigObj = this$1.configify(tplConfig);
      var tpl = tplConfigObj.tpl;
      var joinChar = tplConfigObj.joinChar;
      var control = tplConfigObj.control; // check if tpl could be included in output

      if (this$1.isConditionTruty(tplConfigObj)) {
        if (control) {
          // if tpl is control, execute control flow
          var passingTpl = callMethodOf(this$1, control.toLowerCase(), [tplConfigObj], function () {
            throw ("Provided control '" + control + "' is not valid");
          }); // parse the passing tpl 

          if (passingTpl) { return this$1.parse(passingTpl, joinChar); }
        } else {
          return this$1.isTplParseable(tpl) ? this$1.parse(tpl, joinChar) : tpl;
        }
      }
    }, joinChar, true);
  },

  if: function if$1(ref) {
    var this$1 = this;
    var tpl = ref.tpl;

    return arrify_1(tpl).find(function (tplConfig) {
      if (this$1.isNotValidTplConfig(tplConfig)) { return null; }
      return this$1.isConditionTruty(this$1.configify(tplConfig));
    });
  },

  with: function with$1(ref) {
    var tpl = ref.tpl;
    var resolve = ref.resolve;

    var resolvedValue = isFunction_1(resolve) ? resolve() : resolve;
    return resolvedValue ? tpl(resolvedValue) : null;
  }

};

var rebind = function (obj, method) {
  return obj[method].bind(obj);
};

var callMethodOf = function (obj, methodName, args, fallBackFn) {
  var method = obj[methodName];

  if (method) {
    return method.apply(obj, args);
  } else {
    if (fallBackFn) { return fallBackFn(); }
  }
};

var jsonTemplating = rebind(jsonTemplate, 'parse');

var template = (function (fontConfig, fileResolver) {
  var name = fontConfig.name;
  var weight = fontConfig.weight;
  var display = fontConfig.display;
  var stretch = fontConfig.stretch;
  var style = fontConfig.style;
  var variant = fontConfig.variant;
  var unicodeRange = fontConfig.unicodeRange;
  var featureSettings = fontConfig.featureSettings;
  var variationSettings = fontConfig.variationSettings;

  var urlTemplate = function (name, format) { return ("url('" + name + "') format('" + format + "')"); };

  return jsonTemplating({
    joinChar: ' ',
    tpl: ['@font-face {', ("font-family: '" + name + "';"), {
      condition: weight,
      tpl: ("font-weight: " + weight + ";")
    }, {
      condition: display,
      tpl: ("font-display: " + display + ";")
    }, {
      condition: stretch,
      tpl: ("font-stretch: " + stretch + ";")
    }, {
      condition: style,
      tpl: ("font-style: " + style + ";")
    }, {
      condition: variant,
      tpl: ("font-variant: " + variant + ";")
    }, {
      condition: unicodeRange,
      tpl: ("unicode-range: " + unicodeRange + ";")
    }, {
      condition: featureSettings,
      tpl: ("font-feature-settings: " + featureSettings + ";")
    }, {
      condition: variationSettings,
      tpl: ("font-variation-settings: " + variationSettings + ";")
    }, {
      control: 'with',
      resolve: function () { return fileResolver('eot'); },
      tpl: function (file) { return ("src: url('" + file + "');"); }
    }, {
      control: 'with',
      tpl: function (multipleUrls) { return ("src: " + multipleUrls + ";"); },
      resolve: jsonTemplating({
        joinChar: ' , ',
        tpl: [{
          control: 'with',
          resolve: function () { return fileResolver('eot'); },
          tpl: function (file) { return urlTemplate((file + "#iefix"), 'embedded-opentype'); }
        }, {
          control: 'with',
          resolve: function () { return fileResolver('woff'); },
          tpl: function (file) { return urlTemplate(file, 'woff'); }
        }, {
          control: 'with',
          resolve: function () { return fileResolver('woff2'); },
          tpl: function (file) { return urlTemplate(file, 'woff2'); }
        }, {
          control: 'with',
          resolve: function () { return fileResolver('ttf'); },
          tpl: function (file) { return urlTemplate(file, 'truetype'); }
        }, {
          control: 'with',
          resolve: function () { return fileResolver('svg'); },
          tpl: function (file) { return urlTemplate((file + "#" + name), 'svg'); }
        }]
      })
    }, '}']
  });
});

var index = (function (ref) {
  var directoryContext = ref.directoryContext;
  var fonts = ref.fonts;

  return arrayJoinMap(arrify_1(fonts), function (fontConfig) { return generateFontFace(directoryContext, fontConfig); }, '\n');
}); // DirectoryContext class identifies a specific directory and the files that can be resolved within the dir.

var generateFontFace = function (directoryContext, fontConfig) {
  var fileResolver = function (ext) {
    var fileName = "./" + (fontConfig.file) + "." + ext;
    return directoryContext.exists(fileName) ? directoryContext.resolve(fileName) : null;
  };

  return template(fontConfig, fileResolver);
};

export default index;
//# sourceMappingURL=font-face-core.esm.js.map
